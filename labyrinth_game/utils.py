# labyrinth_game/utils.py

import math

from labyrinth_game.constants import ROOMS


def pseudo_random(seed, modulo):
    """
    Функция будет принимать в качестве параметров число шагов и целое число modulo, 
    на выходе мы должны получить целое в диапазоне [0, modulo) 
    Для создания предсказуемых случайных событий мы используем математику, 
    а не стандартный модуль random. 
    Ваша задача — реализовать простую формулу на основе синуса.
    Функция должна принимать два аргумента: 
    seed (целое число, например, количество шагов) и 
    modulo (целое число для определения диапазона результата).
    Возьмите синус от seed, умноженного на большое число с дробной частью 
    (например, 12.9898).
    Результат умножьте на другое большое число с дробной частью (например, 43758.5453), 
    чтобы "размазать" значения. От полученного числа нам нужна только его дробная часть.
    Простой способ ее получить — вычесть из числа его целую часть (x - math.floor(x)).
    Умножьте эту дробную часть на modulo, чтобы привести значение 
    к нужному диапазону [0, modulo).
    Отбросьте дробную часть и верните целое число.

    Генерирует псевдослучайное целое число в диапазоне [0, modulo) на основе синуса.
    
    Args:
        seed (int): Целое число шагов
        modulo (int): Верхняя граница диапазона результата (не включается)
    
    Returns:
        int: Целое число в диапазоне [0, modulo)
    """
    # Шаг 1: берём синус от seed, умноженного на большое число с дробной частью
    value = math.sin(seed * 12.9898)
        
    # Шаг 2: умножаем результат на другое большое число с дробной частью, 
    # чтобы "размазать" значения
    value *= 43758.5453
        
    # Шаг 3: получаем дробную часть (вычитаем целую часть)
    fractional_part = value - math.floor(value)
        
    # Шаг 4: приводим к нужному диапазону [0, modulo)
    scaled_value = fractional_part * modulo
        
    # Шаг 5: отбрасываем дробную часть и возвращаем целое число
    return int(scaled_value)


def show_help(commands):
    """
    Выводит список доступных команд с описанием.
    
    Параметры:
    commands (dict) — словарь команд и их описаний
    """
    print("\nДоступные команды:\n")
        
    for command, description in commands.items():
        # Форматируем строку: команда слева, описание справа с отступом 16 пробелов
        print(f"{command:<16} {description}")


def describe_current_room(game_state):
    """
    Функция должна принимать один аргумент — словарь game_state.
    Используя game_state['current_room'], получите из константы ROOMS данные 
    о текущей комнате.
    Последовательно выведите на экран:
    Название комнаты в верхнем регистре (например, == ENTRANCE ==).
    Описание комнаты.
    Список видимых предметов. Если они есть, то вывести сообщение "Заметные предметы:"
    с перечисленными предметами
    Доступные выходы("Выходы:").
    Сообщение о наличии загадки, если она есть("Кажется, здесь есть загадка 
    (используйте команду solve).")
    
    Описывает текущую комнату на основе состояния игры.

    Args:
        game_state (dict): Словарь с состоянием игры, 
        должен содержать ключ 'current_room'.
    """
    
    room_name = game_state['current_room']  # название текущей комнаты
    room_data = ROOMS[room_name]  # данные о текущей комнате

    # Название комнаты в верхнем регистре
    print(f"== {room_name.upper()} ==")

    # Описание комнаты
    print(room_data['description'])

    # Список видимых предметов
    if room_data.get('items'):
        print("Заметные предметы:")
        for item in room_data['items']:
            print(f"  -> {item}")

    # Доступные выходы
    exits = room_data.get('exits', [])
    if exits:
        exits_str = ", ".join(exits)
        print(f"Выходы: {exits_str}")

    # Сообщение о загадке
    if room_data.get('puzzle'):
        print("Кажется, здесь есть загадка (используйте команду solve).")


def solve_puzzle(game_state):
    """
    Сначала проверьте, есть ли загадка в текущей комнате. 
    Если нет, выведите сообщение "Загадок здесь нет." и завершите выполнение функции.
    Если загадка есть, выведите на экран вопрос.
    Получите ответ от пользователя("Ваш ответ: ").
    Сравните ответ пользователя с правильным ответом.
    Если ответ верный:
    Сообщите игроку об успехе.
    Уберите загадку из комнаты, чтобы ее нельзя было решить дважды.
    Добавьте игроку награду.
    Если ответ неверный, сообщите об этом игроку("Неверно. Попробуйте снова.").

    Добавьте в логику проверки ответа возможность принимать альтернативные варианты 
    (например, для ответа '10' принимать также 'десять').
    Проверьте, что сделали награду за решение загадки зависимой от комнаты.
    Если игрок дает неверный ответ в trap_room, вызовите функцию trigger_trap().

    Позволяет игроку решить загадку в текущей комнате.
    
    Args:
        game_state (dict): Текущее состояние игры. Должен содержать ключи:
            - 'current_room' (dict): текущая комната с ключом 'puzzle' (опционально)
            - 'player_inventory' (list): инвентарь игрока
            - 'game_over' (bool): флаг окончания игры
    """
    current_room = game_state['current_room']  # название текущей комнаты
    room_data = ROOMS[current_room]  # данные о текущей комнате
    puzzle = room_data.get('puzzle', [])  # загадка в текущей комнате
    
    # Проверяем, есть ли загадка в текущей комнате
    if not puzzle:
        print("Загадок здесь нет.")
        return

    question = puzzle[0]  # вопрос загадки
    answer = puzzle[1] if len(puzzle) > 1 else None  # правильный ответ
    reward = puzzle[2] if len(puzzle) > 2 else None  # награда за отгаданную загадку

    # Выводим вопрос загадки
    print(question)
    
    # Получаем ответ от пользователя
    user_answer = input("Ваш ответ: ")
    
    # Принимаем альтернативные варианты ответа
    match user_answer:
        case 'zero' | 'ноль':
            user_answer = '0'
        case 'one' | 'один':
            user_answer = '1'
        case 'two' | 'два':
            user_answer = '2'        
        case 'three' | 'три':
            user_answer = '3'        
        case 'four' | 'четыре':
            user_answer = '4'        
        case 'five' | 'пять':
            user_answer = '5'        
        case 'six' | 'шесть':
            user_answer = '6'        
        case 'seven' | 'семь':
            user_answer = '7'        
        case 'eight' | 'восемь':
            user_answer = '8'        
        case 'nine' | 'девять':
            user_answer = '9'
        case 'ten' | 'десять':
            user_answer = '10'
        case _:
            user_answer = user_answer.strip().lower()

    # Сравниваем ответ с правильным (без учёта регистра)
    if user_answer == answer.lower():
        print("Правильно! Вы успешно разгадали загадку.")
        
        # Убираем загадку из комнаты
        del room_data['puzzle']

        # Добавляем награду в инвентарь игрока        
        if reward:
            game_state['player_inventory'].append(reward)
            print(f"Вы получили награду: {reward}")
    else:
        if current_room == 'trap_room':
            trigger_trap(game_state)
        if not game_state['game_over']:      
            print("Неверно. Попробуйте снова.")


def attempt_open_treasure(game_state):
    """
    Попытка открыть сундук с сокровищами.
    
    Args:
        game_state (dict): Текущее состояние игры. Должен содержать ключи:
            - 'current_room' (dict): текущая комната с ключом 'puzzle' (опционально)
            - 'player_inventory' (list): инвентарь игрока
    """
    current_room = game_state['current_room']  # название текущей комнаты
    room_data = ROOMS[current_room]  # данные о текущей комнате
    player_inventory = game_state['player_inventory']  # инвентарь игрока
    
    # Проверяем, есть ли сундук в комнате
    if 'treasure_chest' not in room_data.get('items', []):
        print("Здесь нет сундука с сокровищами.")
        return
    
    # Проверяем наличия ключа
    if 'treasure_key' in player_inventory:
        print("Вы применяете ключ, и замок щёлкает. Сундук открыт!")
        
        # Удаляем сундук из комнаты
        room_data['items'].remove('treasure_chest')
        
        print("В сундуке сокровище! Вы победили!")
        game_state['game_over'] = True
        return 'quit'  # Специальный сигнал для выхода
    
    # Если ключа нет — предлагаем ввести код
    choice = input("Сундук заперт. ... Ввести код? (да/нет) ").strip().lower()
        
    if choice in ('да', 'yes', 'y'):
        # Проверяем наличие загадки для сундука
        if 'puzzle' not in room_data:
            print("Не удаётся найти подсказку для ввода кода.")
            return
             
        puzzle = room_data.get('puzzle', [])  # загадка в текущей комнате
    
        question = puzzle[0]  # вопрос загадки
        answer = puzzle[1] if len(puzzle) > 1 else None  # правильный ответ
        # reward=puzzle[2] if len(puzzle) > 2 else None  # награда за отгаданную загадку
        
        print(question)
        user_code = input("Ваш код: ").strip().lower()
        
        if user_code == answer.lower():
            print("Код принят! Замок щёлкает, и сундук открывается.")
            room_data['items'].remove('treasure_chest')
            print("В сундуке сокровище! Вы победили!")
            game_state['game_over'] = True
        else:
            print("Неверный код. Замок не поддаётся.")
    elif choice in ('нет', 'no', 'n'):
        print("Вы отступаете от сундука.")
    else:
        print("Ваш ответ не понятен. Действие отменено.")


def trigger_trap(game_state):
    """
    Эта функция имитирует срабатывание ловушки и должна приводить к негативным 
    последствиям для игрока. Сначала она выведет сообщение, что ловушка активирована 
    (например, "Ловушка активирована! Пол стал дрожать...").
    Проверьте, есть ли у игрока предметы в инвентаре.
    Если инвентарь не пуст, используйте функцию pseudo_random(), чтобы выбрать случайный
    индекс предмета в инвентаре. 
    Удалите этот предмет и сообщите игроку, какой именно предмет он потерял. 
    В качестве значения modulo должно быть количество предметов в инвенторе.
    Если инвентарь пуст, игрок получает "урон". Используйте pseudo_random(), 
    чтобы сгенерировать число (например, от 0 до 9). Если число меньше определенного 
    порога (3), игра заканчивается. 
    Выведите сообщение о поражении и установите game_over в True. В противном случае 
    выведите сообщение, что игрок уцелел.
    
    Активирует ловушку, приводя к негативным последствиям для игрока.
    
    Args:
        game_state (dict): Текущее состояние игры. Должен содержать ключи:
            - 'player_inventory' (list): инвентарь игрока
            - 'game_over' (bool): флаг окончания игры
            - 'steps_taken' (int): счётчик шагов (используется как seed)
    """
    print("Ловушка активирована! Пол стал дрожать...")
    
    inventory = game_state['player_inventory']  # инвентарь игрока
    seed = game_state['steps_taken']  # количество шагов
    
    if inventory:
        # Выбираем случайный индекс предмета в инвентаре для удаления
        modulo = len(inventory)  # количество предметов в инвенторе
        random_index = pseudo_random(seed, modulo)
        
        lost_item = inventory.pop(random_index)
        print(f"Вы потеряли предмет: {lost_item}!")
    else:
        # Инвентарь пуст — проверяем полученный урон
        damage = pseudo_random(seed, 10)  # Число от 0 до 9
        
        if damage < 3:  # Порог для поражения: 30% шанс
            print("Ловушка оказалась смертельной... Вы проиграли!")
            game_state['game_over'] = True
        else:
            print("Вы чудом уцелели! Ловушка не причинила вам вреда.")
    
    # Увеличиваем счётчик шагов для следующего вызова
    game_state['steps_taken'] += 1


def random_event(game_state):
    """
    Создаем небольшие случайные события, которые происходят во время перемещения игрока.
    Сначала определите, произойдет ли событие вообще. 
    Используйте pseudo_random() с modulo (например, 10), чтобы событие происходило 
    с низкой вероятностью (например, если результат равен 0).
    Если событие все же произошло, используйте pseudo_random() еще раз, чтобы выбрать,
    какое именно из нескольких событий случится (например, от 0 до 2).
    Сценарии:
    Сценарий 1 (Находка): Игрок находит на полу монетку. Выведите сообщение об этом 
    и добавьте 'coin' в список предметов текущей комнаты.
    Сценарий 2 (Испуг): Игрок слышит шорох. Выведите сообщение об этом. Если у игрока в
    инвентаре есть 'sword', выведите дополнительное сообщение, что он отпугнул существо.
    Сценарий 3 (Срабатывание ловушки): Проверьте, находится ли игрок в trap_room и 
    отсутствует ли у него в инвентаре 'torch'. Если оба условия верны, выведите 
    сообщение об опасности и вызовите функцию trigger_trap().
    Эту функцию следует вызывать в move_player() после каждого успешного перемещения 
    в новую комнату.

    Генерирует случайное событие при перемещении игрока.
    
    Args:
        game_state (dict): Текущее состояние игры. Должен содержать ключи:
            - 'steps_taken' (int): счётчик шагов для генерации случайности
            - 'player_inventory' (list): инвентарь игрока
            - 'current_room' (dict): текущая комната
    """
    current_room = game_state['current_room']  # название текущей комнаты
    room_data = ROOMS[current_room]  # данные о текущей комнате
    inventory = game_state['player_inventory']  # инвентарь игрока

    # Шаг 1: проверяем, произойдёт ли событие (вероятность ~10%)
    seed = game_state['steps_taken']
    event = pseudo_random(seed, 10)
   
    if event != 0:  # Событие происходит только, если результат = 0
        return  # Ничего не происходит
   
    # Шаг 2: выбираем тип события (3 варианта)
    event_type = pseudo_random(seed + 1, 3)  # +1 чтобы не повторяться
     
    match event_type:
        case 0:
            # Сценарий 1: Находка (монетки)
            print("Вы заметили на полу блестящую монетку!")
            if 'coin' not in room_data.get('items', []):
                room_data['items'].append('coin')
            else:
                print("Но она уже была здесь раньше.")
        
        case 1:
            # Сценарий 2: Испуг (шорох)
            print("Из темноты доносится шорох...")
            if 'sword' in inventory:
                print("Вы выхватаете меч. Шорох затихает. Похоже, что вы отпугнули существо.")  # noqa: E501
            else:
                print("Вы замираете от страха, но ничего не происходит.")
        
        case 2:
            # Сценарий 3: Срабатывание ловушки
            if (current_room == 'trap_room' and 
                    'torch' not in inventory):
                print("Вы слышите странный гул. Пол приходит в движение... О нееет!")
                trigger_trap(game_state)
            else:
                # Если условия ловушки не выполнены, просто описываем опасность
                print("Вы чувствуете, как по спине пробегает холодок. Здесь явно небезопасно.")  # noqa: E501
    
    # Увеличиваем счётчик шагов
    game_state['steps_taken'] += 1